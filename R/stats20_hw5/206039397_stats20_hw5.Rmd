---
title: "Stats 20, W23 -- Homework 5"
author: "Luke Villanueva -- 206039397"
date: "`r format(Sys.Date(), '%D')`"
output:
  html_document:
    toc: yes            # creates table of contents
    toc_depth: 4        # toc will include headers <= ####
    toc_float: yes      # toc always on left of page
    code_folding: show  # allows hiding of code
---

# Question 1

```{r}

char <- c("4", "2", "1", "0")

num <- 0:3

charnum <- data.frame(char, num, stringsAsFactors = TRUE)

```

## a. 

```{r}

as.numeric(char)
as.numeric(charnum$char)

typeof(char)
typeof(charnum$char)

char
charnum$char

as.numeric(factor(c("10","5","1"), ordered = TRUE))

```

Because `char` is itself just a character vector, the type casting can take the raw values of the strings and turn them into numbers. However, `charnum$char` returns the numbers as factored data. This turns the column into a factor, which is casted into their ordering indices by the factor order.

## b.

```{r}
as.numeric(as.character(charnum$char))
```

# Question 2

```{r error = TRUE}
simple_list <- list("vector" = 1:10, "matrix" = matrix(6:1, nrow = 3, ncol = 2))

simple_list$NULL <- NULL
```

## a.

1. NULL is a keyword in R. So, making any object or function just named NULL will not work, for it is a reserved word. 

2. Even if it did successfully create a column named NULL, the value of that column is NULL, so appending a value to a nonexistent column will definitely throw out an error of a nonexistent initialized object.

## b.

```{r}

simple_list <- list("vector" = 1:10, "matrix" = matrix(6:1, nrow = 3, ncol = 2))

simple_list$null_val <- list(NULL)

length(simple_list) == 3

```

## c. 

```{r}

simple_list$vector <- list(NULL)

simple_list$vector

```

# Question 3

```{r}

my_scale <- function(x)
{
  
  a <- 0
  b <- 1
  
  # check if there exists attributes to x
  # if there exists index for both, a and b exist 
  if(length(which(names(attributes(x)) == "a")) != 0 & length(which(names(attributes(x)) == "b")) != 0)
  {
    a <- attributes(x)$a
    b <- attributes(x)$b
  }
  
  # else, just continue the algorithm
  a + (((x - min(x)) * (b - a)) / (max(x) - min(x)))
  
}

# test
x <- 1:20

# test without a and b
my_scale(x)
my_scale(my_scale(x))

# add a and b
attributes(x)$a <- 5
attributes(x)$b <- 2

# test
my_scale(x)
my_scale(my_scale(x))

```

# Question 4

## a. 

The purpose of the given function, `my_eigen`, is to acquire all possible eigenvalues of a any given matrix with additional attributes. 

- Assume all input matrices will always output eigenvalues in the real numbers (i.e. no need to input validate)
- Assume input matrix is diagonalizable. 
  - This means, the following theorem can be used to find a matrix of eigenvalues: `Q^-1 * A * Q = D`, where `Q^-1` and `Q` are the inverse transformation matrix and regular transformation matrix, respectively, A is the original matrix, and D is the diagonal matrix of eigenvalues. 
- The given matrix should have an attribute that's named "Q", which provides the transformation matrix. If not, send out an error.

```{r}

my_eigen <- function(x)
{
  
  # if 0 length, does not exist
  if(length(which(names(attributes(x)) == "Q")) == 0)
  {stop("invalid input, matrix needs Q attribute")}
  
  # otherwise, continue
  # inverse * matrix * Q = D, diagonal are eigenvalues
  diag(solve(x$Q) %*% x %*% Q)

}

```

## b.

The following code will parse through each row of a matrix, outputting a vector following row order.

Error code:
```{r}

vector_by_row <- function(x)
{

  # output
  res <- numeric(0)
  
  for(row in seq_len(ncol(x)))
  {
    for(col in seq_along(ncol(x)))
    {
      res <- c(res, x[row][col])
    }
  }
  
  # output
  res
  
}

```

Fixed code:
```{r}

vector_by_row <- function(x)
{

  # output
  res <- numeric(0)
  
  for(row in seq_len(nrow(x)))
  {
    for(col in seq_len(ncol(x)))
    {
      res <- c(res, x[row,col])
    }
  }
  
  # output
  res
  
}

```

Error 1:
`ncol()` is used as the value in the first for loop's paring condition. The correct answer would utilize `nrow()`, since the algorithm needs to parse all columns of *each* row.

Error 2:
`seq_along()` is used for the parsing condition for the second look. The correct answer would be `seq_len()` because the output of `ncol()` is the number of columns. `seq_along()` would only loop the for loop once, which is an incomplete parsing.

Error 3:
To extract from a matrix, the correct R syntax would be `x[row, col]`. The format `x[row][col]` is from another language, such as C++.

# Question 5

```{r}

my_unlist <- function(x)
{
  
  # output
  res <- NULL
  # if first elem is a factor, make empty factor for res
  if(is.factor(x[[1]]))
  {
    res <- factor()
  }
    
  # parse through all components of list
  for(i in seq_len(length(x)))
  {
    # if list components have lists, apply function recursively
    if(is.list(x[[i]]))
    {
      lapply(x[[i]], my_unlist)
    }
    else
    {
      #concat component to res
      res <- c(res, x[[i]])
    }
  }

  # output
  res
}


# test
unlist(list(c(2, 1, 1), c(3, 2, 1), 2))
my_unlist(list(c(2, 1, 1), c(3, 2, 1), 2))

# test
unlist(list(factor(c("a", "a", "b", "c")),
factor(c("b", "c", "e")),
factor(c("a", "d", "b"))))
my_unlist(list(factor(c("a", "a", "b", "c")),
factor(c("b", "c", "e")),
factor(c("a", "d", "b"))))

# test
unlist(list(factor(c("a", "b")), c(1, 2)))
my_unlist(list(factor(c("a", "b")), c(1, 2)))

# test
unlist(list(factor(c("a", "b")), factor(c("b", "c")), c("a", "b")))
my_unlist(list(factor(c("a", "b")), factor(c("b", "c")), c("a", "b")))

```

## b. 

```{r}

stat_mode <- function(x, first = FALSE)
{

  # result
  res <- NULL
  
  # make unlisted vector, find mode
  x <- unlist(x)
  
  # make vector of unique values
  unique_vec <- unique(x)
  
  # make corresponding vector rep count of each unique entry
  count_vec <- numeric(length(unique_vec))
  
  # fill all 0's
  for(num in count_vec)
  {
    num <- 0
  }
  
  # find mode
  for(entry_indx in seq_along(unique_vec))
  {
    for(i in seq_along(x))
    {
      # check if either NA, then if both are NA
      if(is.na(x[i]) & is.na(unique_vec[entry_indx]))
      {
        count_vec[entry_indx] <- count_vec[entry_indx] + 1
      }
      if(!is.na(x[i]) & !is.na(unique_vec[entry_indx]))
      {
        # if parsed val == entry, count ++
        if(x[i] == unique_vec[entry_indx])
        {
          count_vec[entry_indx] <- count_vec[entry_indx] + 1
        }
      }

    }
  }
  
  # consider first val
  if(first == TRUE)
  {
    res <- unique_vec[1]
  }
  else
  {
    # return index with most count
    res <- unique_vec[which(count_vec == max(count_vec))]
  }
  
  # output
  res

}

# test
stat_mode(c(FALSE, FALSE, TRUE, TRUE, FALSE))

# test
stat_mode(list(c(2, 1, 1), c(3, 2, 1), 2))

# test
stat_mode(list(c(2, 1, 1), c(3, 2, 1), 2), first = TRUE)

# test
stat_mode(list(factor(c("control", "treatment1", "control")),
factor(c("control", "treatment2"))
)
)

```

## c.

```{r}

df_summary <- function(x)
{
  
  # output
  res <- list()
  
  # n_obs = nrow
  res$n_obs <- nrow(x)
  
  # n_var = ncol
  res$n_var <- ncol(x)
  
  # var_names = colnames
  res$var_names <- colnames(x)
  
  # for each column, make sublist
  for(i in seq_len(length(colnames(x))))
  {
    
    # list of each column
    res2 <- list()
    
    # class
    res2$class <- mode(x[[i]])
    
    if(res2$class == "numeric")
    {
      # min
      res2$min <- min(x[[i]], na.rm = TRUE)
      
      # mean
      res2$mean <- mean(x[[i]], na.rm = TRUE)
      
      # max
      res2$max <- max(x[[i]], na.rm = TRUE)
      
      # na count
      res2$na_count <- 0
      for(j in seq_len(length(x[[i]])))
      {
        if(is.na(x[[i]][j]))
        {
          res2$na_count <- res2$na_count + 1
        }
      }
      # end numeric if
    }
    
    # character if
    if(res2$class == "character" | res2$class == "list")
    {
      # modes
      res2$modes <- stat_mode(x[[i]])
      #NOTE: can return length > 1
      
      # mode_count
      res2$mode_count <- numeric(length(res2$modes))
     
      # for all elems in column
      for(j in seq_len(length(x[[i]])))
      {
        # if element equal to elem, get index of elem in modes, use same index in mode_count, increment by 1
        for(modeVal in res2$modes)
        {

          # check if NA
          if(is.na(x[[i]][j]) & is.na(modeVal))
          {
            res2$mode_count[is.na(res2$modes)] <- res2$mode_count[is.na(res2$modes)] + 1
          }
          # only if both not NA
          if(!is.na(x[[i]][j]) & !is.na(modeVal))
          {
            if(x[[i]][j] == modeVal)
            {
              res2$mode_count[which(res2$modes == modeVal)] <- res2$mode_count[which(res2$modes == modeVal)] + 1
            }
          }    

        }
      }
      
    }
    
    # sublist 
    
    # concat res2 to corresponding column data
    res$column_data[[i]] <- res2
    # name column data
    names(res$column_data)[i] <- colnames(x)[i] 

  }
  
  # output
  res
  
}

# test
df <- data.frame(c(88,84,93,NA),c(95,90,99,60),c(NA,NA,88,23),c("Lecture 1","Lecture 1","Lecture 1","Lecture 2"))

colnames(df) <- c("Homework_One", "Homework_Two", "Homework_Three", "Lecture")

str(df_summary(df))
mode(df)

```

## d.

```{r}

load("starwars.RData")

star_sum <- df_summary(starwars)
star_sum

```

## e.

```{r}

star_sum

```

The most common starships used were the X-Wing and the Millenium Falcon, with 3 characters using the X-Win and 2 characters using the Millennium Falcon.