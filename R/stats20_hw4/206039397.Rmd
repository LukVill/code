---
title: "Stats 20, W23 -- Homework 4"
author: "Luke Villanueva -- 206039397"
date: "`r format(Sys.Date(), '%D')`"
output:
  html_document:
    toc: yes            # creates table of contents
    toc_depth: 4        # toc will include headers <= ####
    toc_float: yes      # toc always on left of page
    code_folding: show  # allows hiding of code
---

# Question 1

```{r}

my_t <- function(x)
{
  
  # input validate if matrix
  if(!is.matrix(x))
  {
    # change into matrix
    x <- matrix(x)
    # NOTE: will be 1 column matrix
  }

  # make new matrix with reversed row and col amounts, fill matrix by row
  res <- matrix(as.vector(x), nrow = ncol(x), ncol = nrow(x), byrow = TRUE)
  
  # output
  res
  
}

# test result
test <- matrix(1:6,2,3, byrow = TRUE)

test

my_t(test)

```

# Question 2

## a.

```{r}

my_cor <- function(x, y, use = "everything")
{
  
  # inpute validate, make sure sizes are same
  if(length(x)!=length(y))
  {stop("incompatible dimensions")}
  
  # check use value
  # if use = everything, if there exists 1 NA, return NA
  # if use = "pairwise.complete.obs", skip over NA/NAN/NULL in calculations
  
  res <- NA
  
  if(use == "everything" && (any(is.na(x)) || any(is.na(y))))
  {
    # return NA
    res <- NA
  }
  else
  {
    # if pairwise is used OR there are no NA's, continue with program
    
    # need to calculate:
    # mean of x and y (rm na's)
    # x-xbar and y-ybar
    # sum of diffx * diffy
    # diffx ^2 square root * diff y ^2 square root

    # get indices of NA's and skip them 
    # get numeric bool of indices
    naInX <- as.numeric(is.na(x))
    naInY <- as.numeric(is.na(y))
    
    # add together, then get indices more than 0
    nas <- naInX + naInY
    naIndx <- which(nas > 0)
    
    # remove all pairs with at least one NA
    if(length(naIndx)>0)
    {
      x <- x[-naIndx]
      y <- y[-naIndx] 
    }  
    
    # xbar
    xbar = mean(x)
    
    # ybar
    ybar = mean(y)
    
    # numerator
    num <- sum((x-xbar)*(y-ybar))

    # denominator
    denom <- sqrt(sum((x-xbar)^2)) * sqrt(sum((y-ybar)^2))

    # result
    res <- num/denom
    
  }
  
  # output
  res
  
}

# test values
x <- c(1,NA,5,7,10)
y <- c(7,7,8,15,6)

# cor test
cor(x,y,use = "pairwise.complete.obs")

# my_cor test
my_cor(x,y,use = "pairwise.complete.obs")

```

## b.

```{r}

linreg <- function(x, y, use = "everything")
{
  # output will be numeric(a,b)
  
  
    if(length(x)!=length(y))
  {stop("incompatible dimensions")}
  
  # check use value
  # if use = everything, if there exists 1 NA, return NA
  # if use = "pairwise.complete.obs", skip over NA/NAN/NULL in calculations
  
  res <- NA
  
  if(use == "everything" && (any(is.na(x)) || any(is.na(y))))
  {
    # return NA
    res <- NA
  }
  else
  {
    # if pairwise is used OR there are no NA's, continue with program

    # get indices of NA's and skip them 
    # get numeric bool of indices
    naInX <- as.numeric(is.na(x))
    naInY <- as.numeric(is.na(y))
    
    # add together, then get indices more than 0
    nas <- naInX + naInY
    naIndx <- which(nas > 0)
    
    # remove all pairs with at least one NA
    if(length(naIndx)>0)
    {
      x <- x[-naIndx]
      y <- y[-naIndx] 
    }
    
    # b = r * sd(y)/sd(x)
    b <- cor(x, y, use) * (sd(y)/sd(x))
    
    # a = ybar - b*xbar
    a <- mean(y)- (b * mean(x))
    
    # output
    res <- c(a,b)
  }
  
  # return output
  res
  
}

# test values
x <- c(1,NA,5,7,10)
y <- c(7,7,8,15,6)

# test
linreg(x,y)
linreg(x,y, use = "pairwise.complete.obs")

```

## c.

```{r}

# make height and weight vectors
height <- c(61,62,63,64,66,68)
weight <- c(104,110,125,141,160,170)

linreg(height,weight)

```

The equation of the regression line is `y = -510.64706 + 10.08824x`.

## d. 

```{r}

linreg_mat <- function(x,y)
{
  
  # input validate length
  if(length(x)!=length(y))
  {stop("incompatible dimensions")}
  
  # else, continue
  
  # make 1 column of length x
  mat1col <- rep(1, length(x))
  # make design matrix
  matA <- cbind(mat1col, x)
 
  # get inverse of X^T X
  inv <- solve(t(matA)%*%matA)
  
  # matrix multiply inv,t(x),y
  
  inv %*% t(matA) %*% y
  
}

```

## e.

```{r}

linreg_mat(height,weight)

```

The answers from part c and part e are the same.

## f.

The slope coefficient is estimating that every increment of height by 1 inch increases weight by 10 pounds.


# Question 3

```{r}

`%m%` <- function(A, B)
{
  
  # input check matrix dim are conformable
  if(ncol(A) != nrow(B))
  {
    stop("incompatible dimensions")
  }
  
  # else continue
  
  # make vector of res matrix vals
  vec <- numeric(0)

  for(col in seq_len(ncol(B)))
  {
    for(row in seq_len(nrow(A)))
    {
      vec <- c(vec,sum(A[row,]*B[,col]))
    }
  }
  
  # create result matrix Arow x Bcol
  matrix(vec, nrow(A), ncol(B))
  
}

```

## b. 

```{r}

x <- matrix(6:1, 2, 3, byrow = TRUE)
y <- matrix(1:9, 3, 3)

# real result
x %*% y

# test result
x %m% y

```

# Question 4

## a.

```{r}

`%^%` <- function(A, k)
{
  # input validate, k>0
  if(k < 0)
  {stop("invalid exponent value")}
  
  if(k == 0)
  {
    # make identity matrix
    A <- diag(nrow = nrow(A))
  }
  else
  {
    for(i in seq_len(k))
    {
      A <- A %m% A
    }
  }

  # output 
  A
  
}

```

## b.

```{r}

z <- matrix(c(0.2,0.6,0.4,0.7,0.2,0.1,0.1,0.2,0.5), 3, 3)

z %^% 0

z %^% 5

z %^% 50

z %^% 500

```

# Question 5

```{r}

my_which <- function(x, arr.ind = FALSE)
{
  
  # make res vec/matrix
  res <- integer(0)
  
  # arr.ind makes each row contain row and col indices of each index
  if(is.matrix(x) && arr.ind == TRUE)
  {
    
    res <- matrix(numeric(0), ncol = 2)
    
    for(c in seq_len(ncol(x)))
    {
      for(r in seq_len(nrow(x)))
      {
        if(x[r,c] == TRUE)
        {
          res <- rbind(res,c(r,c))
        }
      }
    }

    # name columns
    colnames(res) <- c("row","col")
    
  }
  else
  {
    # else, parse thru vector (of matrix) and get indices
    for(i in seq_along(as.vector(x)))
    {
      if(x[i] ==  TRUE)
      {
        res <- c(res, i)
      }
    }
  }
  
  # output
  res
  
}

# test
xvec <- 1:12
xmat <- matrix(1:12,3,4)

# test xvec

which(xvec%%2==0,arr.ind = FALSE)

my_which(xvec%%2==0,arr.ind = FALSE)

which(xvec%%2==0,arr.ind = TRUE)

my_which(xvec%%2==0,arr.ind = TRUE)

# test xmat

which(xmat%%2==0,arr.ind = FALSE)

my_which(xmat%%2==0,arr.ind = FALSE)

which(xmat%%2==0,arr.ind = TRUE)

my_which(xmat%%2==0,arr.ind = TRUE)

```

# Question 6

## a.