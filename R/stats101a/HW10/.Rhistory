rm()
ls()
rm(ls())
rm(list = ls())
rep(0,n)
rep(0,10)
library(tidyverse)
library(MASS)
library(car)
realty <- read.delim(paste0(getwd(),"/realty.txt"), sep = "\t")
glimpse(realty)
table(realty$type)
realty2 <- filter(realty,type=="Condo/Twh"|type=="SFR")%>%filter(sqft>0&bath>0)
realty3 <-realty2%>%mutate(lprice=log(price))
glimpse(realty3)
m1 <- lm(lprice ~ city + bed + bath + sqft, realty3)
summary(m1)
unique(realty3$city)
summary(update(m1,.~. - bed))
library(lattice)
xyplot(lprice ~ bath|bed, realty3)
xyplot(lprice ~ sqft | city, realty3)
msmall <- lm(price~bed+bath+sqft,data=realty3)
msmall.log <- lm(lprice~bed+bath+sqft, data=realty3)
mmps(msmall)
mmps(msmall.log)
salary <- read.csv(paste0(getwd(),"/salary.csv"), stringsAsFactors = TRUE)
glimpse(salary)
summary(lm(Salary ~ Expernc + Gender, salary))
summary(lm(Salary ~ Expernc + Gender + Expernc:Gender, salary))
summary(lm(Salary ~ Expernc + Expernc:Gender, salary))
mmps(lm(Salary ~ Expernc + Expernc:Gender, salary))
summary(m1)
predict(m1, list(bed = 2), interval = "c", level = 0.95)
predict(m1, list(city = 2), interval = "c", level = 0.95)
predict(m1, list(city = "Westwood", bed = 2, bath = 2, sqft = 5000), interval = "c", level = 0.95)
predict(m1, list(city = "Westwood", bed = 2, bath = 2), interval = "c", level = 0.95)
predict(m1, list(city = "Westwood", bed = 2, bath = 2, , sqft = 5000), interval = "c", level = 0.95)
predict(m1, list(city = "Westwood", bed = 2, bath = 2, sqft = 5000), interval = "c", level = 0.95)
summary(m1)
mmp(m1)
summary(m1)
mmp(m1,bed)
mmp(m1,x)
mmp(m1)
mmps(msmall)
mmps(lm(Salary ~ Expernc + Expernc:Gender, salary))
help(regsubsets)
install.packages("leaps")
help(regsubsets)
library(leaps)
help("regsubsets")
source("C:/Users/lavil/source/repos/LukVill/code/R/stats101a/final.R", echo=TRUE)
summary(m1)
plot(m1)
plot(m1)
plot(sqrt(m1$residuals)~m1$fitted.values)
plot(m1)
sigma <- 50
# data 1
y1 <- 10 + 15*x + 0.5*x^2+rnorm(100,0,sigma)
m1 <- lm(y1~x)
plot(m1)
# data 2
y2 <- 10 + 15*x + 0.5*x^2 + rnorm(100,0,sigma)
m2 <- lm(y2~x + I(x^2))
plot(m2)
# data 3
y3 <- 10 + 15*x + rnorm(100,0,(x+abs(min(x))+1)*sigma)
m3 <- lm(y3~x)
plot(m3)
plot(m3)
plot(rstandard(m1))
plot(rstandard(m1)~x)
plot(rstandard(m1)~x)
source("C:/Users/lavil/source/repos/LukVill/code/R/stats101a/final.R", echo=TRUE)
plot(rstandard(m1)~x)
plot(rstandard(m2)~x)
(rstandard(m3)~x)
plot(rstandard(m3)~x)
plot(rstandard(m4)~x)
plot(rstandard(m2)~x)
plot(rstandard(m1)~x)
plot(rstandard(m3)~x)
plot(rstandard(m1)~x)
plot(rstandard(m2)~x)
plot(rstandard(m4)~x)
setwd("C:/Users/lavil/source/repos/LukVill/code/R/stats101a/HW10")
library(tidyverse)
pga <- read.csv(paste0(getwd(),"/pgatour2006-3.csv"))
glimpse(pga)
m <- lm(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
summary(m)
boxcox(m)
library(car)
boxcox(m)
car::boxcox(m)
help(mmp)
help(mmps)
help(boxcox)
help(boxCox)
help(vif)
help(gvif)
help(gvif)
help(car::gvif)
help(car::vif)
help("gvif")
car::box.cox(m)
car::boxCox(m)
# powertransform
summary(powerTransform(m))
help("powerTransform")
# powertransform
summary(powerTransform(c(pga$DrivingAccuracy,pga$GIR)))
# powertransform
summary(powerTransform(cbind(pga$DrivingAccuracy,pga$GIR)))
# powertransform
summary(powerTransform(c(pga$DrivingAccuracy,pga$GIR)))
# powertransform
summary(powerTransform(cbind(pga$DrivingAccuracy,pga$GIR)))
# powertransform
summary(powerTransform(cbind(pga$DrivingAccuracy,pga$GIR)~1))
# boxcox
car::boxCox(m)
# boxcox
summary(car::boxCox(m))
car::boxCox(m)
# powertransform
summary(powerTransform(m))
# inverse response
car::inverseResponsePlot(m)
# powertransform
summary(powerTransform(m))
# boxcox
car::boxCox(m)
glimpse(pga)
MASS:boxCox(pga$PrizeMoney)
car:boxCox(pga$PrizeMoney)
car::boxCox(pga$PrizeMoney)
mas::boxCox(pga$PrizeMoney)
MASS::boxCox(pga$PrizeMoney)
car::boxCox(pga$PrizeMoney)
car::boxCox(cbind(pga$PrizeMoney))
powerTransform(m)
summary(powerTransform(m))
summary(powerTransform(rbind(pga$PrizeMoney,pga$AveDrivingDistance)))
summary(powerTransform(cbind(pga$PrizeMoney,pga$AveDrivingDistance)))
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
# powertransform
summary(powerTransform(m))
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
summary(powerTransform(cbind(pga$PrizeMoney)))
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)~1))
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
summary(powerTransform(m))
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
# x1 might be 0
summary(powerTransform(pga$DrivingAccuracy))
# x1 might be 0
summary(powerTransform(pga$GIR))
# check all variables
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
m <- lm(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
# model
car::vif(m)
# plot
plot(m)
# update model to squareroot the Y variable
update(m, sqrt(PrizeMoney)~.)
m
# update model to squareroot the Y variable
update(m, sqrt(PrizeMoney)~.)
m
# update model to squareroot the Y variable
update(m, sqrt(PrizeMoney)~.)
m
# update model to squareroot the Y variable
m <- update(m, sqrt(PrizeMoney)~.)
m
m <- lm(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
# check all variables
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
# update model to log the Y variable
m <- update(m, log(PrizeMoney)~.)
m
# model
car::vif(m)
inverseResponsePlot(m)
car::boxCox(m)
summary(powerTransform(m))
mmps(m)
mmp(m)
mmps(m)
# plot data
xyplot(y~.|.)
help(xyplot)
help("xyplot")
# plot data
car::xyplot(y~.|.)
# plot data
MASS::xyplot(y~.|.)
# plot data
lattice::xyplot(y~.|.)
# plot data
lattice::xyplot(y~.)
# plot data
lattice::xyplot(PriceMoney~DrivingAccuracy,pga)
# plot data
lattice::xyplot(PrizeMoney~DrivingAccuracy,pga)
# plot data
lattice::xyplot(PrizeMoney~.,pga)
# plot data
lattice::xyplot(PrizeMoney~DrivingAccuracy|BirdieConversion,pga)
plot(m)
summary(m)
plot(PrizeMoney~DrivingAccuracy)
plot(PrizeMoney~DrivingAccuracy, pga)
# plot
plot(m)
# plot
plot(m)
rstandard(m)
# plot
plot(m)
pga
plot(m)
# high leverage
4/nrow(pga)
plot(m)
nrow(pga)
# high leverage
4/nrow(pga)
plot(m)
# high leverage
2*(7 + 1)/nrow(pga)
plot(m)
# high leverage
2*(7 + 1)/nrow(pga)
plot(m)
car::vif(m)
summary(m)
car::vif(m)
help("regsubset")
leaps::
leaps::
help("regsubsets")
aic(m)
stats::aic(m)
stats::AIC(m)
help("AIC")
stats::BIC(m)
leaps::regsubsets(m)
help("regsubsets")
leaps::regsubsets(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, data = pga)
leaps::regsubsets(pga$PrizeMoney ~ pga$DrivingAccuracy + pga$GIR + pga$PuttingAverage + pga$BirdieConversion + pga$SandSaves + pga$Scrambling + pga$PuttsPerRound)
leaps::regsubsets(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, data = pga)
summary(leaps::regsubsets(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, data = pga))
stats::AIC(lm(PrizeMoney~DrivingAccuracy,pga))
7!
factorial(7)
help("stepwise")
stats::BIC(m)
m$coefficients
m
# get power transformations on y and x
# check all variables
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
# only PrizeMoney needs to be log transformed
# update model to log the Y variable
m <- update(m, log(PrizeMoney)~.)
# plot
plot(m)
library(tidyverse)
library(car)
pga <- read.csv(paste0(getwd(),"/pgatour2006-3.csv"))
glimpse(pga)
m <- lm(PrizeMoney ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
# boxcox
car::boxCox(m)
# powertransform
summary(powerTransform(m))
# inverse response
car::inverseResponsePlot(m)
# get power transformations on y and x
# check all variables
summary(powerTransform(cbind(pga$PrizeMoney, pga$DrivingAccuracy, pga$GIR, pga$PuttingAverage, pga$BirdieConversion, pga$SandSaves, pga$Scrambling, pga$PuttsPerRound)))
# only PrizeMoney needs to be log transformed
# update model to log the Y variable
m <- update(m, log(PrizeMoney)~.)
# plot
plot(m)
summary(m)
car::vif(m)
stats::AIC(lm(PrizeMoney~DrivingAccuracy,pga))
stats::BIC(m)
help("AIC")
help("regsubsets")
m
#summary(leaps::regsubsets())
bestmodel <- leaps::regsubsets(m)
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
summary(bestmodel)
sumModel <- summary(bestmodel)
sumModel$bic
stats::BIC(sumModel)
stats::BIC(bestmodel)
sumModel$bic
n = nrow(pga)
n
plot(sumModel)
sumModel
sumModel$bic
sumModel$bic
sumModel
stats::AIC(lm(log(PrizeMoney)~GIR,pga))
sumModel$bic
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
sumModel$bic[1]
BICToAIC(sumModel$bic[1],n,1)
stats::AIC(lm(log(PrizeMoney)~GIR,pga))
stats::BIC(lm(log(PrizeMoney)~GIR,pga))
# convert bic to aic
seq_along(sumModel$bic)
sumModel
# convert bic to aic
BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
# get summary
sumModel <- summary(bestmodel)
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
which(min(aic))
which(aic == min(aic))
which(bic == min(bic))
# get model with lowest aic and bic
which(aic == min(aic))
sumModel
which(bic == min(bic))
sumModel
help("regsubsets")
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# get summary
sumModel <- summary(bestmodel)
sumModel
bestmodelback <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "b")
sumbackmodel <- summary(bestmodelback)
sumbackmodel
bestmodelback <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "b")
sumbackmodel <- summary(bestmodelback)
# convert bic to aic
aicback <- BICToAIC(sumbackmodel$bic,n,seq_along(sumbackmodel$bic))
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# make function to use regsubsets obj and provide aic
# and bic analysis
aicbicanalysis <- function(regsubObj, sumModel, data, methodStr)
{
# get summary
sumModel <- summary(bestmodel)
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
# get model with lowest aic and bic
which(aic == min(aic))
which(bic == min(bic))
sumModel
}
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# make function to use regsubsets obj and provide aic
# and bic analysis
aicbicanalysis <- function(regsubObj, data)
{
# get summary
sumModel <- summary(bestmodel)
n <- nrow(pga)
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
# get model with lowest aic and bic
which(aic == min(aic))
which(bic == min(bic))
sumModel
}
aicbicanalysis(bestmodel, pga)
# get model with lowest aic and bic
which(aic == min(aic))
which(bic == min(bic))
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# make function to use regsubsets obj and provide aic
# and bic analysis
aicbicanalysis <- function(regsubObj, data)
{
# get summary
sumModel <- summary(bestmodel)
n <- nrow(pga)
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
# get model with lowest aic and bic
print(which(aic == min(aic)))
print(which(bic == min(bic)))
print(sumModel)
}
aicbicanalysis(bestmodel, pga)
# get model with lowest aic and bic
print("Best AIC Model",which(aic == min(aic)))
# get model with lowest aic and bic
print(paste0("Best AIC Model",which(aic == min(aic))))
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# make function to use regsubsets obj and provide aic
# and bic analysis
aicbicanalysis <- function(regsubObj, data)
{
# get summary
sumModel <- summary(bestmodel)
n <- nrow(pga)
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
# get model with lowest aic and bic
print(paste0("Best AIC Model: ",which(aic == min(aic))))
print(paste0("Best BIC Model: ", which(bic == min(bic))))
print(sumModel)
}
aicbicanalysis(bestmodel, pga)
bestmodelback <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "b")
aicbicanalysis(bestmodelback,pga)
bestmodelback <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "b")
aicbicanalysis(bestmodelback,pga)
# do regression algo
bestmodel <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "e")
# using algebra manipulation, bic conversion is this function
BICToAIC <- function(bic,n,p)
{bic - (log(n) - 2)*p}
# make function to use regsubsets obj and provide aic
# and bic analysis
aicbicanalysis <- function(regsubObj, data)
{
# get summary
sumModel <- summary(regsubObj)
n <- nrow(pga)
# convert bic to aic
aic <- BICToAIC(sumModel$bic,n,seq_along(sumModel$bic))
# get bic
bic <- sumModel$bic
aic
bic
# get model with lowest aic and bic
print(paste0("Best AIC Model: ",which(aic == min(aic))))
print(paste0("Best BIC Model: ", which(bic == min(bic))))
print(sumModel)
}
aicbicanalysis(bestmodel, pga)
bestmodelback <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "b")
aicbicanalysis(bestmodelback,pga)
aicbicanalysis(bestmodelforward,pga)
bestmodelforward <- leaps::regsubsets(log(PrizeMoney) ~ DrivingAccuracy + GIR + PuttingAverage + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga, method = "f")
aicbicanalysis(bestmodelforward,pga)
summary(bestmodelforward)$bic
summary(bestmodelback)$bic
finalModel <- lm(log(PrizeMoney)~GIR + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
summary(finalModel)
car::vif(finalModel)
finalModel <- lm(log(PrizeMoney)~GIR + BirdieConversion + SandSaves + Scrambling + PuttsPerRound, pga)
summary(finalModel)
plot(finalModel)
(2*6)/(nrow(pga))
plot(finalModel)
2/11*9/4
15*11
165-27
9*22
198/22
198+9
207/22
